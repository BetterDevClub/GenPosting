@page "/linkedin"
@using GenPosting.Shared.DTOs
@using GenPosting.Web.Services
@inject HttpClient Http
@inject NavigationManager Nav
@inject ILinkedInStateService LinkedInState
@inject ISnackbar Snackbar

<PageTitle>LinkedIn Dashboard</PageTitle>

<MudText Typo="Typo.h3" Class="mb-4">LinkedIn Dashboard</MudText>

@if (!LinkedInState.IsAuthenticated)
{
    <MudPaper Class="pa-8 d-flex flex-column align-center justify-center" Elevation="2">
        <MudIcon Icon="@Icons.Custom.Brands.LinkedIn" Size="Size.Large" Color="Color.Primary" Class="mb-4" Style="font-size: 4rem;" />
        <MudText Typo="Typo.h5" Class="mb-4">Connect your LinkedIn Account</MudText>
        <MudText Typo="Typo.body1" Class="mb-6">Connect to view your posts and analytics.</MudText>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" Size="Size.Large" OnClick="ConnectLinkedIn" StartIcon="@Icons.Custom.Brands.LinkedIn">
            Connect LinkedIn
        </MudButton>
    </MudPaper>
}
else
{
    <MudGrid>
        <MudItem xs="12">
            <MudPaper Class="pa-4 d-flex justify-space-between align-center">
                <MudText Typo="Typo.h6">Connected Account</MudText>
                <MudButton Variant="Variant.Outlined" Color="Color.Error" OnClick="Disconnect">Disconnect</MudButton>
            </MudPaper>
        </MudItem>

        <MudItem xs="12">
            <MudPaper Class="pa-4">
                <MudText Typo="Typo.h6" Class="mb-4">Create New Post</MudText>
                
                <MudGrid>
                    <MudItem xs="12" md="6">
                         <MudTextField @bind-Value="_newPostContent" Label="What do you want to talk about?" Variant="Variant.Outlined" Lines="8" Class="mb-4" HelperText="Write your post content here." Adornment="Adornment.End" AdornmentIcon="@Icons.Material.Filled.Edit" />
                         
                         <MudFileUpload T="IReadOnlyList<IBrowserFile>" FilesChanged="OnFilesChanged" MaximumFileCount="9" Accept=".jpg, .jpeg, .png, .gif, .mp4">
                            <ActivatorContent>
                                <MudButton Variant="Variant.Outlined" Color="Color.Primary" StartIcon="@Icons.Material.Filled.AttachFile">
                                    Attach Media (Images or 1 Video)
                                </MudButton>
                            </ActivatorContent>
                         </MudFileUpload>

                         @if (_files != null && _files.Any())
                         {
                             <MudList T="IBrowserFile" Dense="true">
                                 @foreach (var file in _files)
                                 {
                                     <MudListItem Icon="@Icons.Material.Filled.FilePresent">
                                         @file.Name (@(file.Size / 1024) KB)
                                     </MudListItem>
                                 }
                             </MudList>
                             <MudButton Variant="Variant.Text" Color="Color.Error" OnClick="ClearFiles" Class="mt-2">Clear Media</MudButton>
                         }

                         <MudDivider Class="my-4"/>
                         <MudText Typo="Typo.subtitle2" Class="mb-2">Follow-up Comments</MudText>
                         @for (int i = 0; i < _comments.Count; i++)
                         {
                             var index = i; 
                             <div class="d-flex gap-2 mb-2">
                                <MudTextField Value="@_comments[index]" ValueChanged="@((string s) => _comments[index] = s)" Label="@($"Comment #{index+1}")" Variant="Variant.Outlined" Margin="Margin.Dense" FullWidth="true"/>
                                <MudIconButton Icon="@Icons.Material.Filled.Delete" Color="Color.Error" OnClick="@(() => RemoveComment(index))" />
                             </div>
                         }
                         <MudButton StartIcon="@Icons.Material.Filled.AddComment" Variant="Variant.Text" Color="Color.Secondary" OnClick="AddCommentField">Add Follow-up Comment</MudButton>


                         <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="CreatePost" Disabled="@(_posting || (string.IsNullOrWhiteSpace(_newPostContent) && (_files == null || !_files.Any())))" FullWidth="true" Class="mt-4 py-2" StartIcon="@Icons.Material.Filled.Send">
                            @if (_posting)
                            {
                                <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true"/>
                                <MudText Class="ms-2">Posting... @(_uploadProgress > 0 ? $"{_uploadProgress}%" : "")</MudText>
                            }
                            else
                            {
                                <MudText>Post Now</MudText>
                            }
                        </MudButton>
                    </MudItem>
                    
                    <MudItem xs="12" md="6">
                         <GenPosting.Web.Components.LinkedInPostPreview Content="@_newPostContent" AuthorName="@(_profile?.Name ?? "Your Name")" AuthorAvatarUrl="@(_profile?.PictureUrl)" Images="@_previewImages" VideoUrl="@_previewVideoUrl" /> 
                    </MudItem>
                </MudGrid>
            </MudPaper>
        </MudItem>

        <MudItem xs="12">
            <MudText Typo="Typo.h5" Class="mt-4 mb-2">Recent Posts</MudText>
            
            @if (_loading)
            {
                <MudProgressCircular Indeterminate="true" Color="Color.Primary" />
            }
            else if (_posts == null || !_posts.Any())
            {
                <MudAlert Severity="Severity.Info">No posts found or unable to fetch posts.</MudAlert>
            }
            else
            {
                <MudGrid>
                    @foreach (var post in _posts)
                    {
                        <MudItem xs="12" md="6" lg="4">
                            <MudCard>
                                <MudCardContent>
                                    <MudText Typo="Typo.caption">@post.PublishedAt.ToString("g")</MudText>
                                    <MudText Typo="Typo.body2" Class="mt-2 text-truncate" Style="height: 60px;">@post.Content</MudText>
                                    <MudDivider Class="my-2"/>
                                    <div class="d-flex justify-space-between">
                                        <MudText Typo="Typo.caption"><MudIcon Icon="@Icons.Material.Filled.ThumbUp" Size="Size.Small"/> @post.Metrics.Likes</MudText>
                                        <MudText Typo="Typo.caption"><MudIcon Icon="@Icons.Material.Filled.Comment" Size="Size.Small"/> @post.Metrics.Comments</MudText>
                                        <MudText Typo="Typo.caption"><MudIcon Icon="@Icons.Material.Filled.Share" Size="Size.Small"/> @post.Metrics.Shares</MudText>
                                        <MudText Typo="Typo.caption"><MudIcon Icon="@Icons.Material.Filled.Visibility" Size="Size.Small"/> @post.Metrics.Views</MudText>
                                    </div>
                                </MudCardContent>
                            </MudCard>
                        </MudItem>
                    }
                </MudGrid>
            }
        </MudItem>
    </MudGrid>
}

@code {
    private List<LinkedInPostDto>? _posts;
    private LinkedInProfileDto? _profile;
    private bool _loading = false;
    private bool _posting = false;
    private string _newPostContent = string.Empty;
    
    private IReadOnlyList<IBrowserFile>? _files;
    private List<string> _previewImages = new();
    private string? _previewVideoUrl;
    private int _uploadProgress = 0;
    
    private List<string> _comments = new();

    private void AddCommentField() => _comments.Add(string.Empty);
    private void RemoveComment(int index)
    {
         if (index >= 0 && index < _comments.Count) _comments.RemoveAt(index);
    }

    protected override async Task OnInitializedAsync()
    {
        if (LinkedInState.IsAuthenticated)
        {
            await LoadProfile();
            await LoadPosts();
        }
    }
    
    private async Task OnFilesChanged(IReadOnlyList<IBrowserFile> files)
    {
        _files = files;
        _previewImages.Clear();
        _previewVideoUrl = null;

        if (files == null || !files.Any()) return;

        var first = files.First();
        var isVideo = first.ContentType.StartsWith("video/", StringComparison.OrdinalIgnoreCase);
        
        if (isVideo)
        {
            if (files.Count > 1) 
            {
                Snackbar.Add("You can only upload one video at a time.", Severity.Warning);
                _files = null;
                return;
            }
            _previewVideoUrl = "VIDEO_SELECTED"; // Placeholder as we can't easily preview video file stream
        }
        else
        {
            foreach(var f in files)
            {
                if (f.ContentType.StartsWith("video/", StringComparison.OrdinalIgnoreCase))
                {
                     Snackbar.Add("Cannot mix images and video.", Severity.Warning);
                     _files = null;
                     _previewImages.Clear();
                     return;
                }
                
                try 
                {
                    // resizing for preview to save memory and speed up
                    var resized = await f.RequestImageFileAsync(f.ContentType, 600, 600);
                    var buffer = new byte[resized.Size];
                    await resized.OpenReadStream().ReadAsync(buffer);
                    var base64 = Convert.ToBase64String(buffer);
                    _previewImages.Add($"data:{f.ContentType};base64,{base64}");
                } 
                catch (Exception ex) 
                {
                    Console.WriteLine($"Preview error: {ex.Message}");
                }
            }
        }
    }

    private void ClearFiles()
    {
        _files = null;
        _previewImages.Clear();
        _previewVideoUrl = null;
    }

    private async Task LoadProfile()
    {
        try 
        {
            var request = new HttpRequestMessage(HttpMethod.Get, "/api/linkedin/profile");
            request.Headers.Add("X-LinkedIn-Token", LinkedInState.AccessToken);
            var response = await Http.SendAsync(request);
            if (response.IsSuccessStatusCode)
            {
                _profile = await response.Content.ReadFromJsonAsync<LinkedInProfileDto>();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading profile: {ex.Message}");
        }
    }

    private async Task CreatePost()
    {
        if (string.IsNullOrWhiteSpace(_newPostContent) && (_files == null || !_files.Any())) return;

        _posting = true;
        _uploadProgress = 0;
        try
        {
            var mediaUrns = new List<string>();
            var mediaType = "NONE";

            // 1. Upload Media step
            if (_files != null && _files.Any())
            {
                var isVideo = _files.First().ContentType.StartsWith("video/", StringComparison.OrdinalIgnoreCase);
                mediaType = isVideo ? "VIDEO" : "IMAGE";
                int count = 0;
                
                foreach (var file in _files)
                {
                     count++;
                     _uploadProgress = (int)((count / (double)_files.Count) * 50); // First 50%
                     StateHasChanged(); // Force UI update for progress

                     using var content = new MultipartFormDataContent();
                     using var stream = file.OpenReadStream(maxAllowedSize: 50 * 1024 * 1024); // 50MB limit
                     using var fileContent = new StreamContent(stream);
                     fileContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(file.ContentType);
                     content.Add(fileContent, "file", file.Name);
                     
                     var uploadReq = new HttpRequestMessage(HttpMethod.Post, "/api/linkedin/upload");
                     uploadReq.Headers.Add("X-LinkedIn-Token", LinkedInState.AccessToken);
                     uploadReq.Content = content;
                     
                     var uploadRes = await Http.SendAsync(uploadReq);
                     if (!uploadRes.IsSuccessStatusCode)
                     {
                         var err = await uploadRes.Content.ReadAsStringAsync();
                         throw new Exception($"Failed to upload media: {err}");
                     }
                     
                     var uploadResult = await uploadRes.Content.ReadFromJsonAsync<LinkedInUploadResponse>();
                     if (uploadResult != null) mediaUrns.Add(uploadResult.AssetUrn);
                }
            }
            
            _uploadProgress = 75;
            StateHasChanged();

            // 2. Post Creation
            var request = new HttpRequestMessage(HttpMethod.Post, "/api/linkedin/post");
            request.Headers.Add("X-LinkedIn-Token", LinkedInState.AccessToken);
            request.Content = JsonContent.Create(new CreateLinkedInPostRequest(_newPostContent, mediaUrns, mediaType, _comments));

            var response = await Http.SendAsync(request);
            if (response.IsSuccessStatusCode)
            {
                Snackbar.Add("Post created successfully!", Severity.Success);
                _newPostContent = string.Empty;
                ClearFiles();
                _comments.Clear();
                await LoadPosts(); 
            }
            else
            {
                var errorMsg = await response.Content.ReadAsStringAsync();
                Snackbar.Add($"Failed to create post. Status: {response.StatusCode}. {errorMsg}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error creating post: {ex.Message}", Severity.Error);
        }
        finally
        {
            _posting = false;
            _uploadProgress = 0;
        }
    }

    private async Task ConnectLinkedIn()
    {
        try
        {
            var callbackUrl = Nav.ToAbsoluteUri("/linkedin-callback").ToString();
            // Encode the callback URL properly for the query parameter
            var encodedCallback = Uri.EscapeDataString(callbackUrl);
            var response = await Http.GetFromJsonAsync<LinkedInAuthUrlResponse>($"/api/linkedin/auth-url?redirectUri={encodedCallback}");
            
            if (response != null && !string.IsNullOrEmpty(response.AuthUrl))
            {
                Nav.NavigateTo(response.AuthUrl, forceLoad: true);
            }
            else
            {
                Snackbar.Add("Failed to get authorization URL", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadPosts()
    {
        _loading = true;
        try
        {
            var request = new HttpRequestMessage(HttpMethod.Get, "/api/linkedin/posts");
            request.Headers.Add("X-LinkedIn-Token", LinkedInState.AccessToken);
            
            var response = await Http.SendAsync(request);
            if (response.IsSuccessStatusCode)
            {
                _posts = await response.Content.ReadFromJsonAsync<List<LinkedInPostDto>>();
            }
            else if (response.StatusCode == System.Net.HttpStatusCode.Unauthorized)
            {
                Snackbar.Add("Session expired. Please reconnect.", Severity.Warning);
                Disconnect();
            }
            else
            {
                Snackbar.Add($"Failed to load posts. Status: {response.StatusCode}", Severity.Warning);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error loading posts: {ex.Message}", Severity.Error);
        }
        finally
        {
            _loading = false;
        }
    }

    private void Disconnect()
    {
        LinkedInState.AccessToken = null;
        _posts = null;
        Snackbar.Add("Disconnected", Severity.Success);
    }
}
